"""Flight data recorder

Extrernal (to X-Plane) application to create a FDR file during a flight.

File first collect FDR header information such as aircraft type and registration, date, and basic weather information.
It then permanently collects FDR data, a set of mandatory data (ZULU time, longitude, latitude, altitude, magnetic heading, pitch and roll),
and a set of optional dataref.

Dataref values get saved every WRITE_FREQUENCY and written FLUSH_FREQUENCY second.

Currently use Websocket API. TO do: Use alternate protocols: REST, UDP. Should work out of the box.

"""

import os
import sys
import logging
import argparse
import datetime
from typing import Dict
from time import sleep
import traceback

sys.path.append(os.path.join(os.path.dirname(__file__), ".."))

import xpwebapi
from xpwsapp import XPWSAPIApp

FORMAT = "[%(asctime)s] %(levelname)s %(threadName)s %(filename)s:%(funcName)s:%(lineno)d: %(message)s"
logging.basicConfig(level=logging.INFO, format=FORMAT, datefmt="%H:%M:%S")

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)
# logger.setLevel(logging.DEBUG)


# From sample FDR 4 data file:
#
# ACFT: aicraft path in X-Plane
# TAIL: tail number
# DATE: local time in xx/xx/xx format
# PRES: local baro pressure in inches
# DISA: temperature offset from ISA in degrees C
# WIND: wind direction and speed in knots
#
# Example:
# ACFT, Aircraft/Laminar Research/Lancair Evolution/N844X.acf
# TAIL, N844X
# DATE, 01/18/2023
# PRES, 30.01
# DISA, 0
# WIND, 270,15
#
HEADER = {
    "sim/aircraft/view/acf_relative_path",
    "sim/aircraft/view/acf_tailnum",
    "sim/cockpit2/clock_timer/current_month",
    "sim/cockpit2/clock_timer/current_day",
    "sim/weather/barometer_current_inhg",
    "sim/weather/barometer_sealevel_inhg",
    "sim/weather/aircraft/wind_now_direction_degt",
    "sim/weather/aircraft/wind_now_speed_msc",  # 1 m/s = 1,94384449 knt
}

# "Mandatory" FDR data at start of each CSV line
#
# They MUST BE the ZULU time, then the longitude, latitude, altitude in feet, magnetic heading in degrees, then pitch and roll in degrees.
# Note: Not sure where to fetch temperature offset from ISA.
FDR_DATA = [
    "sim/cockpit2/clock_timer/zulu_time_hours",
    "sim/cockpit2/clock_timer/zulu_time_minutes",
    "sim/cockpit2/clock_timer/zulu_time_seconds",
    "sim/flightmodel/position/longitude",
    "sim/flightmodel/position/latitude",
    "sim/flightmodel/position/elevation",
    "sim/cockpit2/gauges/indicators/heading_electric_deg_mag_pilot",
    "sim/cockpit2/gauges/indicators/pitch_electric_deg_pilot",
    "sim/cockpit2/gauges/indicators/roll_electric_deg_pilot",
]

# Additional datarefs that user wants to be saved
#
FDR_OPTIONAL = set()

try:
    from fdr_optional import FDR_OPTIONAL

    logger.info(f"imported {len(FDR_OPTIONAL)} optional datarefs")
except ImportError:
    pass

# Default values
#
SCRIPT_NAME = os.path.basename(__file__)
SCRIPT_VERSION = "1.0.0"

FDR_FILENAME = "out.fdr"
WRITE_FREQUENCY = 1.0  # seconds
REPORT_FREQUENCY = 20.0  # seconds, 0 to disable


class FDR(XPWSAPIApp):

    def __init__(self, api, filename: str = FDR_FILENAME, frequency: float = WRITE_FREQUENCY) -> None:
        XPWSAPIApp.__init__(self, api=api)

        self.filename = filename
        self.frequency = frequency
        self.header = {d: False for d in HEADER}
        self.lines = []
        self.file = None
        self.writes = 0
        self.optional_datarefs: Dict[str, xpwebapi.Dataref] = {}

    @property
    def header_ok(self) -> bool:
        return all(self.header.values())

    def get_dataref_names(self) -> set:
        return HEADER | set(FDR_DATA) | set(FDR_OPTIONAL)

    def dataref_value(self, dataref: str, is_string: bool = False, rounding: int | None = None):
        dref = self.datarefs.get(dataref)
        if dref is None:
            logger.warning(f"dataref {dataref} not found")
            return "" if is_string else 0
        if is_string:
            value = dref.get_string_value(encoding="ascii")
            return value
        if rounding is not None:
            return round(dref.value, rounding)
        return dref.value

    def print_header(self):
        with open(self.filename, "w") as fp:
            # FDR Header
            print("A\r4\n", file=fp)  # note A may not be visible on Apple computers because of simple carriage return after it (no new line)

            print(f"COMM, generated by demonstration {SCRIPT_NAME} script rel. {SCRIPT_VERSION}, xpwebapi rel. {xpwebapi.version}", file=fp)
            print(f"COMM, on {datetime.datetime.now().replace(microsecond=0).astimezone().isoformat()}\n", file=fp)

            # FDR Meta data
            print(f"ACFT, {self.dataref_value('sim/aircraft/view/acf_relative_path', is_string=True)}", file=fp)
            print(f"TAIL, {self.dataref_value('sim/aircraft/view/acf_tailnum', is_string=True)}", file=fp)
            print(
                f"DATE, {self.dataref_value('sim/cockpit2/clock_timer/current_month')}/{self.dataref_value('sim/cockpit2/clock_timer/current_day')}/2025",
                file=fp,
            )  # MM/DD/YYYY
            print(f"PRES, {self.dataref_value('sim/weather/barometer_sealevel_inhg', rounding=2)}", file=fp)
            print("DISA, 0", file=fp)
            print(
                f"WIND, {int(self.dataref_value('sim/weather/aircraft/wind_now_direction_degt'))}, {round(self.dataref_value('sim/weather/aircraft/wind_now_speed_msc') * 1.94384449, 2)}",
                file=fp,
            )

            # FDR Data
            if len(FDR_OPTIONAL) > 0:
                print("\nCOMM, Additional datarefs", file=fp)
                for d in FDR_OPTIONAL:
                    comment = ""
                    dref = self.datarefs.get(d)
                    if dref is None:
                        logger.warning(f"dataref {d} not found, not monitored")
                        print(f"COMM, WARNING: dataref {d} not found, not monitored", file=fp)
                        continue
                    elif not dref.valid:
                        print(f"COMM, WARNING: dataref {d} not valid, not monitored", file=fp)
                        logger.warning(f"dataref {d} is not valid, not monitored")
                        continue
                    elif not dref.is_writable:
                        logger.warning(f"dataref {d} is not writable, will be monitored")
                        comment = "not writable"
                    print(f"DREF, {d}  1.0 // comment: {comment}", file=fp)
                    self.optional_datarefs[d] = dref

            # CSV Header as a comment
            optional = "" if len(self.optional_datarefs) == 0 else ", " + ", ".join(self.optional_datarefs.keys())
            print("\nCOMM, UTC time, longitude, latitude, altmsl(ft), heading, pitch, roll" + optional + "\n", file=fp)

        logger.debug("FDR header written")

    def print_line(self) -> str:
        base = datetime.datetime.now(datetime.UTC).strftime("%H:%M:%S.%f, ")
        values = [self.dataref_value(d) for d in FDR_DATA if "zulu" not in d]
        values[2] = float(values[2]) * 3.28084
        base = base + ", ".join([f"{v}" for v in values])
        optional = "" if len(self.optional_datarefs) == 0 else ", " + ", ".join([f"{self.dataref_value(d)}" for d in self.optional_datarefs.keys()])
        return base + optional + "\n"

    def loop(self):
        print(">>>>>>>>>>> STARTED")
        traceback.print_stack()
        r = 100000
        if REPORT_FREQUENCY > 0:
            r = int(self.frequency if self.frequency > REPORT_FREQUENCY else REPORT_FREQUENCY / self.frequency)
        logger.info("FDR writer started")
        while not self.file.closed:
            self.file.write(self.print_line())
            self.writes = self.writes + 1
            self.file.flush()
            if self.writes % r == 0:
                logger.info(f"..FDR written.. ({self.writes})")
            sleep(self.frequency)
        logger.info("FDR writer stopped")

    def dataref_changed(self, dataref, value):
        self.datarefs[dataref].value = value
        if not self.header_ok:
            if dataref in HEADER:
                self.header[dataref] = True
                if self.header_ok:
                    self.start()
                return

            # buffering lines every second while header not written
            if dataref == "sim/cockpit2/clock_timer/zulu_time_seconds":
                self.lines.append(self.print_line())

    def start(self):
        if not self.header_ok:
            return
        # writing header
        self.print_header()
        # writing buffered lines
        self.file = open(self.filename, "a")
        for l in self.lines:
            self.writes = self.writes + 1
            self.file.write(l)
        logger.debug(f"FDR {len(self.lines)} buffered lines written")
        self.lines = []
        super().start()

    def stop(self):
        if self.file is not None:
            self.file.close()
            self.file = None


if __name__ == "__main__":

    parser = argparse.ArgumentParser(description="Show simulator time")
    parser.add_argument("--version", action="store_true", help="shows version information and exit")
    parser.add_argument("--use-beacon", action="store_true", help="REMOTE USE ONLY: attempt to use X-Plane UDP beacon to discover network address")
    parser.add_argument("--host", nargs=1, help="REMOTE USE ONLY: X-Plane hostname or ip address (default to localhost)")
    parser.add_argument("--port", nargs="?", help="REMOTE USE ONLY: X-Plane web api TCP/IP port number (defatul to 8086)")
    parser.add_argument("-v", "--verbose", action="store_true", help="shows more information")

    args = parser.parse_args()

    if args.verbose:
        logging.basicConfig(level=logging.DEBUG)

    if args.version:
        print(version)
        os._exit(0)

    probe = None
    api = None

    if args.use_beacon:
        probe = xpwebapi.beacon()
        api = xpwebapi.ws_api()
        probe.set_callback(api.beacon_callback)
        probe.start_monitor()
    else:
        if args.host is not None and args.port is not None:
            if args.verbose:
                logger.info(f"api at {args.host}:{args.port}")
            api = xpwebapi.ws_api(host=args.host, port=args.port)
        else:
            if args.verbose:
                logger.info("api at localhost:8086")
            api = xpwebapi.ws_api()

    logger.debug("starting..")
    app = FDR(api, frequency=1.0)
    try:
        app.run()
    except KeyboardInterrupt:
        logger.warning("terminating..")
        app.terminate()
        logger.warning("..terminated")
